---
layout: post
title: "top, sysstat 등을 활용한 시스템 부하 및 자원 상태 확인하기"
categories: devops
tags: linux
---

시스템의 자원을 모두 사용하면 시스템의 응답이 느려지는데, 이러한 문제 해결을 위한 기본적인 지표로 평균 부하를 볼 수 있다.

평균 부하란, CPU를 사용하고 있거나(Running), 사용을 위해 대기중이거나(Ready), I/O를 기다리고 있는(Waiting) 프로세스들의 평균 개수이다.

예를 들어 시스템에 CPU가 1개만 있을 경우에, 평균 부하 1은 CPU가 쉬지 않고 일을 처리하고 있었다는 뜻이며, 평균 부하 2의 경우에는 2배의 부하가 걸려 있었다는 뜻이다.

같은 방식으로, CPU가 4개 있을 경우에 평균 부하 4는 4개의 CPU가 일을 하던 것이다.

간단한 명령어 uptime 은 이러한 평균 부하를 보여준다.

```bash
$ uptime
 07:56:46 up 18 min,  1 user,  load average: 2.65, 1.92, 1.27
```

load average 옆에 나오는 3개의 실수값은 각각 1분, 5분, 15분 동안의 평균 부하를 나타낸다.

```grep -c processor /proc/cpuinfo```는 내 시스템의 코어 개수를 출력해주는데, 8개였기 때문에 현재 그렇게 부하가 많이 걸려 있지 않음을 확인할 수 있다.

시간 경과에 따른 부하를 같이 보여줌으로써, 현재 상태에 대한 측정과 더불어 부하가 올라가는 중인지 내려가는 중인지에 대해서도 알 수 있다.

<br>

그러나 uptime 보다 더 많은 정보를 지속적으로 보여주는 top 이라는 좋은 모니터링 도구가 있다.

```bash
$ top
top - 08:13:46 up 35 min,  1 user,  load average: 0.81, 1.21, 1.36
Tasks: 278 total,   2 running, 276 sleeping,   0 stopped,   0 zombie
%Cpu(s):  4.7 us,  4.7 sy,  0.0 ni, 90.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   7692.4 total,   2763.7 free,   2219.2 used,   2709.4 buff/cache
MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   4604.6 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
   3476 bconfid+  20   0 2735296 353772 127380 S  27.8   4.5  11:56.37 Isolated Web Co
   1512 bconfid+   9 -11 3066536  21604  16624 R  16.7   0.3   2:25.17 pulseaudio
   2823 bconfid+  20   0 6353152 744788 380888 S  11.1   9.5   7:37.53 GeckoMain
   1611 bconfid+  20   0  858204  84168  45752 S   5.6   1.1   1:49.70 Xorg
   3761 bconfid+  20   0  247848  52204  43740 S   5.6   0.7   3:53.55 RDD Process
   5465 bconfid+  20   0   21920   4048   3396 R   5.6   0.1   0:00.03 top
      1 root      20   0  167596  11296   8084 S   0.0   0.1   0:01.70 systemd
      2 root      20   0       0      0      0 S   0.0   0.0   0:00.00 kthreadd
      3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp
      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_par_gp
      6 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/0:0H-events_highpri
      9 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 mm_percpu_wq
     10 root      20   0       0      0      0 S   0.0   0.0   0:00.00 rcu_tasks_rude_
```

uptime 에서 제공하는 시스템이 얼마나 오래 가동되었는지, 평균 부하는 몇인지 등에 대한 정보 뿐만 아니라 실행 중인 프로세스들, 메모리 사용량, 프로세스 목록과 프로세스별 자원 사용량 등을 실시간으로 갱신해 콘솔에 출력해준다.

top 은 기본적으로 대화형 모드로 실행되기 때문에 화면 크기에 맞춰 지속적으로 업데이트되는데, 결과만 보고 싶을 경우에는 ```top -b -n 1``` 처럼 배치 모드로 출력 횟수를 지정하여 실행할 수 있다.

top 이 출력하는 내용들을 보면, 첫번째 줄은 uptime 결과와 동일한 형식이다.

바로 아래에는 태스크들의 상태를 보여주며, 3번째 줄에는 CPU가 현재 하고 있는 일들에 관한 추가적인 통계치를 제공해준다.

| us | user cpu time, nice가 적용되지 않은 사용자프로세스의 cpu 사용 시간에 대한 비율 |
| sy | system cpu time, 커널프로세스의 cpu 사용 시간에 대한 비율 |
| ni | nice cpu time, nice가 적용된 프로세스의 cpu 사용 시간 비율 |
| id | idle cpu time, cpu가 사용되지 않는, 유휴 상태의 비율 |
| wa | IO wait, cpu가 I/O를 대기하면서 소비한 시간의 비율(Busy Waiting) |
| hi | hardware interrupts, 하드웨어 인터럽트를 제공하는데 cpu가 소비한 시간의 비율 |
| si | software interrupts, 소프트웨어 인터럽트를 제공하는데 cpu가 소비한 시간의 비율 |
| st | steal time, 가상 머신을 위해 다른 태스크에서의 cpu 사용 시간에 대한 비율 |

위에서의 id 값은 90.5로 cpu가 약 90퍼센트 정도 쉬고 있었다는 뜻이 되는데, 실제로 1분간 평균 부하가 0.8 이었던 것으로 보아(코어 개수 8개) 10퍼센트 정도만 cpu를 사용하고 있었음을 볼 수 있다.

사용자의 cpu 사용률이 높은 경우에는 일반적으로 서버에서 돌아가는 특정 서비스에서 부하를 잡아먹고 있다는 뜻이 되는데, 이는 top 에서 제공되는 프로세스 목록들로 쉽게 확인 가능하다.

기본적으로 프로세스들을 cpu 사용률을 기준으로 높은 순으로 정렬해서 출력해주기 때문에, 현재는 PID 3476 을 가진 Isolated Web 어쩌고가 가장 cpu 를 많이 사용하는 프로세스인 것이다.

cpu 사용률은 cpu 1개에 대한 비율이기 때문에, cpu가 여러개 있는 시스템일 경우 하나 이상의 프로세스가 99%의 사용률을 보일 수도 있다.

한두개의 프로세스가 cpu 자원을 모두 사용하는 경우에는 해당 프로세스를 강제적으로 종료시킬 수 있다.

만약 수많은 프로세스에 의해 자원이 고갈된 경우는, 아마 cron 등으로 인해 프로세스가 너무 많이 실행되는 상황일텐데, 부하가 낮아질때 까지 프로세스를 종료시키거나 서비스의 부하를 여러 서버에 분산시킬 수 있겠다.

<br>

MiB Mem :   7692.4 total,   2763.7 free,   2219.2 used,   2709.4 buff/cache
MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   4604.6 avail Mem 

top은 메모리 사용량에 대한 통계치도 제공하는데, MiB Mem 과 Mib Swap 으로 시작하는 두 줄이다.

첫번째 줄(MiB Mem)은 앞에서부터 각각 물리 메모리의 전체 크기, 여유 공간, 얼마나 사용 하였는지, 버퍼/캐시로 얼마나 사용되었는지에 대해 보여준다.

두번째 줄(MiB Swap)은 스왑 영역에 대한 정보들을 위와 동일하게 보여주는데, 마지막 항목은 실제로 사용 가능한 메모리 크기이다.

첫번째 줄에서의 free 영역의 크기와 두번째 줄에서 사용 가능한 메모리 크기가 다른 이유는 파일 캐시 때문이다.

리눅스에서는 파일을 메모리에 불러온 뒤, 프로그램이 종료되었다고 해서 메모리에서 바로 제거하지 않고, 다음에 또 접근할 때 디스크IO를 발생시키지 않기 위해 메모리에 캐싱해놓기 때문이다.

스왑 영역은 메모리를 모두 사용했을 때, 디스크를 메모리처럼 사용할 수 있게 하는 영역이라고 볼 수 있다.

즉 다른 프로세스가 사용할 메모리 공간을 확보하기 위해서 유휴 프로세스의 메모리를 디스크의 스왑 영역으로 옮기는 것인데, 현재는 여유가 있기 때문에 스왑 영역을 사용하지 않는 걸 확인할 수 있다.

기본적으로 top에서는 프로세스 목록을 cpu사용량을 기준으로 한다고 했지만, M 키를 누를 경우 메모리 사용률을 기준으로 바꿔 보여준다.

<br>

top 으로 매번 확인하고있는 것이 아니기 때문에, 문제가 발생한 시점에 때마침 모니터링을 하고 있을 경우는 별로 없다.

크론잡으로 top 을 배치실행시켜 주기적으로 파일에 저장해놓을 수 있지만, 이를 이미 sysstat 이라는 패키지에서 제공하고 있다.

먼저 ```sudo apt-get install sysstat```으로 패키지를 설치한 뒤, sar 명령어를 쳐보면 아래처럼 아무것도 뜨지 않는다고 나온다.

```bash
$ sar
Cannot open /var/log/sysstat/sa05: No such file or directory
Please check if data collecting is enabled
```

일반적으로 데비안 계열 시스템에서는 sysstat 을 꺼놨기 때문에, ```/etc/default/sysstat``` 에서 ENABLED="true" 로 변경해줘야 한다.

sysstat이 활성화되면, 기본적으로 이러한 통계 정보들을 10분마다 ```/var/log/sysstat``` 에 저장하며(sar 명령어가 읽어오는 위치), 매일 자정마다 날짜별로 기록된다.

이러한 설정에 대해 변경하고 싶으면 ```/etc/cron.d/sysstat```에서 크론잡을 수정 가능하다.

```bash
$ sar
Linux 5.13.0-28-generic (GRAM) 	2022년 02월 05일 	_x86_64_	(8 CPU)

09시 05분 01초     CPU     %user     %nice   %system   %iowait    %steal     %idle
09시 15분 01초     all     10.42      0.00      4.60      0.01      0.00     84.97
Average:        all     10.42      0.00      4.60      0.01      0.00     84.97
```

sar 은 기본적으로 오늘의 cpu 사용에 대한 통계치를 보여준다.

```bash
sar -r
Linux 5.13.0-28-generic (GRAM) 	2022년 02월 05일 	_x86_64_	(8 CPU)

09시 05분 01초 kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
09시 15분 01초   2570876   4665828   2178136     27.65    112892   2789752   8576068     85.98    906676   3451652         0
Average:      2570876   4665828   2178136     27.65    112892   2789752   8576068     85.98    906676   3451652         0
```

r 옵션을 같이 사용할 경우에는 메모리에 대한 통계치를 보여준다.

이외에도 다른 지표들에 대한 정보를 옵션별로 제공하는데, b 옵션은 디스크I/O, -n DEV 를 붙이면 네트워크 I/O 등이 있으며 A 옵션의 경우에는 이외에도 많은 정보들을 한번에 출력해준다.