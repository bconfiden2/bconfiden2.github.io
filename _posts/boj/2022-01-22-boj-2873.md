---
layout: post
title:  "[백준] 2873 : 롤러코스터"
subtitle:  ""
categories: ps
tags: boj
---

[문제 바로가기](https://www.acmicpc.net/problem/2873) --- **Platinum 3** --- *# Implementation # Greedy # Constructive*

---

각 칸에 들어가는 값은 모두 양의 정수이기 때문에, 특정 위치를 지난다고 해서 최대값에 손해를 보는 곳은 없다.

무조건 많이 탐색하는 것이 이득인데, 이 때 이러한 경로들 중 최대값을 갖는 경로를 찾는 문제이다.

조금만 생각해보면, 가로 혹은 세로 둘중 하나라도 홀수값을 가질 경우 모든 위치를 다 지날 수 있음을 알 수 있다.(예제 입력 1)

그러나 예제 2번처럼, R이랑 C 값이 모두 짝수일 경우에는 모든 위치를 다 지날 수 없는데, 이 경우에도 최소한 점 하나만을 제외한 나머지 위치들을 전부 지날 수 있다.

(r+c)가 홀수인 r행 c열 위치를 제외할 경우에는 해당 지점만을 제외하면 전부 지날 수 있다.

(r+c)가 짝수인 위치일 경우에는, 해당 위치에 같은 방향으로 인접한 2개 지점(예를 들어 r,c=(2,2)인 경우, (1,2),(2,2),(3,2) 혹은 (2,1),(2,2),(2,3))을 제외한 나머지 모든 지점을 지날 수 있다.

그러나 실질적으로는 (r+c)가 짝수인 위치와 인접한 2개 위치를 제외하는 것보다, (r+c)가 홀수인 한개 지점만 제외하는것이 무조건적으로 최대 합이 커진다.

(r+c)가 짝수인 위치와 인접한 2개 위치는 반드시 (r+c)가 홀수인 지점들이 되기 때문이다.

따라서 (r+c)가 홀수인 위치들 중, 가장 값이 작은 한개 위치만 제외하고 나머지 지점들을 전부 방문하는 식으로 탐색한다.

탐색 경로에는 일정한 패턴이 정해져 있는데, 우선 R과 C가 모두 짝수이기 때문에 모든 행과 열들을 2줄 단위로 나눌 수 있다.

제외할 (r,c) 위치가 포함된 2개 행을 기준으로 위쪽은 시작점부터 역ㄷ 자 모양으로 쭉 내려올 수 있고, 아래쪽은 ㄷ 자 모양으로 도착지까지 내려갈 수 있다.

비슷한 패턴으로 (r,c) 위치가 포함된 2개 행 안에서도, 2개 열씩 묶어 똑같은 패턴이 등장하기 때문에 전체 탐색 경로를 쉽게 구할 수 있다.

---

```python
import sys
R, C = map(int, input().split())
graph = [list(map(int, line.split())) for line in sys.stdin]
ans = ""
# R,C 둘중 하나라도 홀수일 경우 모든 점 포함 가능
if R%2 == 1:
    for l in range(R):
        ans += (('R'*(C-1) if l%2 == 0 else 'L'*(C-1)) + 'D')
elif C%2 == 1:
    for l in range(C):
        ans += (('D'*(R-1) if l%2 == 0 else 'U'*(R-1)) + 'R')
else:
    # 빠질 점 선택
    x, y = min((graph[r][c],(r,c)) for r in range(R) for c in range(C) if (r+c)%2 != 0)[1]
    # 빠지는 점 직전까지의 줄들(2줄 단위)
    ans += ('R'*(C-1) + 'D' + 'L'*(C-1) + 'D') * (x//2)
    # 빠질 점이 포함된 2줄
    ans += 'DRUR' * (y//2) + ('DR' if x%2==0 else 'RD') + ('RURD' * (((C-1)//2+1)-(y//2+1))) + 'D'
    # 나머지 줄들(2줄 단위)
    ans += ('L'*(C-1) + 'D' + 'R'*(C-1) + 'D') * (((R-1)//2+1)-(x//2+1))
print(ans[:-1])
```
