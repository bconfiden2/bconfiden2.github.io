---
layout: post
title:  "[백준] 2140 : 지뢰찾기"
subtitle:  ""
categories: ps
tags: boj
---

**Gold 5** --- *# Greedy*

<br>

[문제 바로가기](https://www.acmicpc.net/problem/2140)

---

문제 조건으로, 보드에서 ```테두리만 열려있고 나머지 가운데 부분은 모두 닫혀있다```고 주어졌다.

그렇기 때문에 (0,0) 위치의 값으로는 반드시 1 혹은 0 밖에 들어오지 않는다. 해당 위치에서 셀 수 있는 지뢰는 (1,1) 밖에 없기 때문이다.

(0,0) 위치의 값에 따라 (1,1) 위치의 지뢰 여부가 정해지면, 다음으로 열려있는 (0,1) 위치의 값에 대해서도 확정지을 수 있다.

이미 (1,1) 위치의 지뢰 여부가 정해졌기 때문에, (0,1) 위치가 조절할 수 있는 지뢰는 (1,2) 위치밖에 없기 때문이다.

마찬가지로 (0,1) 위치가 (1,2)의 지뢰를 정하면, (0,2) 위치는 (1,3) 지뢰 밖에 정하지 못하는 것이다.

이렇게 자신이 정할 수 있는 지뢰들을 정해나가면서 같은 행의 지뢰를 다 채운 이후 다음 행으로 넘어가는데, 이미 (1,1) 지뢰가 정해져있기 때문에 (1,0) 위치는 (2,1) 지뢰밖에 정하지 못한다.

따라서 ```(0,0) 부터 오른쪽 아래 방향으로 지뢰들을 검사```하면서, ```자신이 정할 수 있는 지뢰 위치를 채워나가는 방식```으로 그리디하게 풀어낼 수 있다.

---
<br>

```python
N = int(input())
board = [list(input()) for _ in range(N)]

# 왼쪽 위부터 오른쪽 아래까지 순서대로 채워나감
for r in range(N):
    for c in range(N):
        # 가장자리 부분(열린 부분)만 검사
        if board[r][c] in ('#', 'O', 'X'):
            continue
        # target = 내 주변에 채워야 할 폭탄의 수, bombs = 실제로 주변에 폭탄이 얼마나 차있는지
        target = int(board[r][c])
        bombs = 0
        # 해당 위치에서 8개 방향을 확인
        for ir in (-1,0,1):
            for ic in (-1,0,1):
                if ir==0 and ic==0: continue
                nr, nc = r+ir, c+ic
                # 검사할 인접 위치 (nr,nc)의 인덱스 확인한 뒤
                if 0 <= nr < N and 0 <= nc < N:
                    # 아직 채워지지 않은 곳이라면
                    if board[nr][nc] == '#':
                        # 이미 내 할당량의 폭탄이 주변에 다 차있다면 이번 위치는 불가능 표시
                        if bombs == target:
                            board[nr][nc] = 'X'
                        # 아직 채워야 할 폭탄 수가 남아있다면 채워줌
                        else:
                            board[nr][nc] = 'O'
                            bombs += 1
                    # 이전 검사에서 채워진 폭탄들도 셈
                    elif board[nr][nc] == 'O':
                        bombs += 1

# 폭탄을 실제로 채운 위치들 + 검사되지 않은 중간부분은 모두 폭탄으로 처리해서 최대값 구함
print(sum(int(board[r][c] in ('#', 'O')) for r in range(N) for c in range(N)))
```