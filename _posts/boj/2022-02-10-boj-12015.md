---
layout: post
title:  "[백준] 12015 : 가장 긴 증가하는 부분 수열 2"
subtitle:  ""
categories: ps
tags: boj
---

[문제 바로가기](https://www.acmicpc.net/problem/12015) --- **Gold 2** --- *# Tags*

---

기존에 이와 비슷한 유형의 문제를 풀 때는, 특정 위치에서의 dp값을 구하기 위해 이전 dp값들을 전부 훑으며, 들어갈 수 있는 수열의 길이 + 1 로 갱신했다.

즉 문제의 핵심은, ```현재 원소값보다 작은 원소값들 중 가장 큰 dp 값```에 1을 더하면 되는 것이었다.

dp배열에 (원소값, dp값) 들이 둘 다 오름차순을 기준으로 정렬되어 있다면, 현재 원소값의 lower bound 위치 직전에 존재하는 값의 dp 값이, 앞서 말한 찾으려는 값이 된다.

그러나 이 경우는, 원소들이 들어올 때 마다 logN 으로 값을 찾을 수는 있지만 매번 정렬을 하기 때문에 비용적으로 부담이 많이 간다.

따라서 가장 긴 증가하는 부분 수열에 해당하는 배열을 만든 뒤, 원소를 탐색해나가며 이 배열을 채워나가는 방식으로 풀어야 한다.

현재 원소값이 배열의 가장 큰 수보다 더 클 경우에는, 당연히 증가하는 부분 수열이 만들어지기 때문에 배열의 맨 뒤에다가 추가해주면 된다.

만약 작을 경우에는, 앞서 등장한 값들 중 현재 원소보다 작았던 값들과, 뒤에 나올 큰 원소들로 구성된 또다른 부분 수열이 탄생할 수 있기 때문에 이에 대한 처리가 필요한데, 이 부분을 lower bound 탐색으로 해결한다.

현재 원소값보다 크거나 작은 값들 중 가장 작은 값을 현재 원소값으로 교체해주는 것이다.

이렇게 할 시 왼쪽에는 작았던 값들이 그대로 유지되지만, 오른쪽에 위치한 값들은 현재값보다 앞서 나왔지만 더 큰 값들이기 때문에 수열이 깨지는 문제가 발생한다.

그러나 가장 긴 증가하는 부분 수열 자체에 대한 추적이 필요한 것이 아니고 길이만 알면 되기 때문에 가능한 것으로, 어차피 뒤에서 현재 원소값보다 큰 값들이 계속해서 나올 경우에는 오른쪽에 있던 값들이 하나씩 갱신될 것이기 때문이다.

만약 나오지 않는다고 하더라도, 부분 수열의 길이 자체는 배열의 길이가 변하지 않을 것이기 때문에 원소의 순서가 망가진다고 하더라도 문제가 발생하지 않는다.

---

```python
N = int(input())
A = list(map(int, input().split()))
arr = [A[0]]

# 특정 값보다 크거나 같은 값들 중 가장 작은 값의 인덱스
def lower_bound(arr, val):
    ldx, rdx = 0, len(arr)
    while ldx < rdx:
        mdx = (ldx + rdx) // 2
        if arr[mdx] >= val:
            rdx = mdx
        else:
            ldx = mdx + 1
    return ldx

for v in A:
    # 만약 더 큰 값이 들어올 경우에는 길이 1 추가
    if v > arr[-1]:
        arr.append(v)
    # 그 외에는 lowerbound 값을 대체
    # arr 자체는 증가하는 부분수열대로 유지되지는 않지만, 길이는 유지 가능
    else:
        arr[lower_bound(arr, v)] = v
print(len(arr))

```
