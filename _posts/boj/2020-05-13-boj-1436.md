---
layout: post
title: "[백준] 1436.cpp : 영화감독 숌"
subtitle: ""
categories: ps
tags: boj
---

*# 백준 # 완전 탐색*

<br>

[문제 바로가기](https://www.acmicpc.net/problem/1436)

<br>

---

- 패턴을 찾아내려다가 생각해보니 문자열 비교를 하면 될 것 같았다. 그런데 테스트케이스로 반복하는 것이 아니라 한번만 찾으면 되기 때문에 굳이 최댓값이 10000개를 구해놓을 필요 없이, n 을 패턴에 의해 잘라내서 값을 찾는게 효율적이어 보였다.
- 패턴 방식은 너무 로직이 복잡해지고 꼬여서 포기. 문자열 비교로 풀어보자
- 패턴으로 풀때는 1시간 반? 2시간? 정도 규칙찾으면서 디버깅하느라 죽을 뻔 했는데 문자열 비교로 푸니까 바로 풀었다...ㅎㅎ...
- 모조리 검사하는 완전탐색 방식의 문제가 너무싫다. 왠지 그렇게 풀면 비효율적인 것 같아서 이 악물고 다른 방식을 찾아내려고 하는데 결국 실패하면 너무 허탈하다.
- 최댓값 10000개를 다 구해놓고 입력받은 값을 인덱스로 사용해 푸신 분도 계시다. 이게 오히려 문자열 검사보다 시간이 훨씬 빠 르기도 하다.
- 문자열로 비교 할 필요 없이 숫자를 10씩 나눠가면서 검사하는 것이 더 좋을 것 같다. (평균 40ms vs 240ms)
- 실제로 패턴으로 푸신 분이 있는데 잘 이해가 안간다. 계속 읽어볼 것 (17901246) (15933800)

---
<br>

{% highlight c++ %}

#include <cstdio>
#include <string>
using namespace std;
int main(void)
{
  int n = 0;
  scanf("%d", &n);

  int count = 0;
  int answer = 0;
  int val = 666;

  // 666이 들어간 숫자를 1씩 증가하면서 n번 찾는다
  while(count != n)
  {
    // 666이 들어가있는 숫자라면 count 1 증가, 정답 업데이트하기를 반복
    if(to_string(val).find("666") != string::npos)
    {
      count++;
      answer = val++;
    }
  }
  // 끝나면 answer 에 n번째 666이 포함된 문자가 들어있음
  printf("%d\n", answer);
}

{% endhighlight %}

