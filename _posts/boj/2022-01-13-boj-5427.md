---
layout: post
title:  "[백준] 5427 : 불"
subtitle:  ""
categories: ps
tags: boj
---

**Gold 4** --- *# Implementation # Graph Theory # Graph Traversal # Breadth-first Search*

<br>

[문제 바로가기](https://www.acmicpc.net/problem/5427)

---

상근이가 빌딩을 탈출한다는 것은, w * h 짜리 빌딩 바깥으로 벗어난다는 것이다.

상근이가 한칸 이동할때마다 불도 사방으로 퍼지기 때문에, 불이 퍼지는 곳은 이동이 불가능하다.

즉 상근이가 이동 불가능한 지역은, 이미 자신이 방문했던 위치, 불이 지나간 위치, 벽이 있다.

따라서 bfs 를 돌리면서 매 반복마다 이동 가능한 위치들에 대해서만 검사해주고, 불 역시 매 반복마다 사방으로 퍼뜨려준다.

다만 이번에 불이 퍼지는 칸으로는 상근이가 이동할 수 없기 때문에, 불 확산에 대한 처리를 우선적으로 수행해주면 된다.

불은 상근이가 이미 지나왔던 자리로 붙어봤자 상근이의 탈출에는 영향이 없다.

그러므로 불을 확산시킬 때도 역시 벽, 이미 불이 지나간 위치, 이미 상근이가 지나간 위치를 제외하고 확산 가능한 자리로만 이동시킨다.

---
<br>

```python
import sys
input = sys.stdin.readline

# 테스트케이스별로 bfs
def bfs(graph, q, fq):
    answer = 1
    while len(q) > 0:
        nq, nfq = [], []
        # 불이 먼저 4방향으로 확산됨
        for r, c in fq:
            for nr, nc in ((r+1,c),(r-1,c),(r,c+1),(r,c-1)):
                if 0 <= nr < R and 0 <= nc < C:
                    if not graph[nr][nc]:
                        nfq.append((nr, nc))
                        graph[nr][nc] = True
        # 불 확산 처리 이후에 상근이가 이동(이제 불이 붙으려는 칸으로 이동 X)
        for r, c in q:
            for nr, nc in ((r+1,c),(r-1,c),(r,c+1),(r,c-1)):
                if 0 <= nr < R and 0 <= nc < C:
                    if not graph[nr][nc]:
                        nq.append((nr, nc))
                        graph[nr][nc] = True
                # 상근이는 인덱스 범위를 벗어날 경우 탈출된 것
                else:
                    return str(answer)
        fq = nfq
        q = nq
        answer += 1
    return "IMPOSSIBLE"

for tc in range(int(input())):
    C, R = map(int, input().split())
    graph, q, fq = [], [], []
    for r in range(R):
        row = []
        for c, v in enumerate(input().strip()):
            # 빈 공간만 미방문 처리 해놓고
            if v == '.':
                row.append(False)
            # 나머지(벽, 상근, 불)은 전부 방문 처리
            else:
                row.append(True)
                # 어차피 상근이가 이미 지나간 공간은 불이 따라와봤자 무의미
                if v == '@':
                    q.append((r, c))
                # 불이 지나간 공간 역시 상근이가 못지나감
                elif v == '*':
                    fq.append((r, c))
        graph.append(row)
    print(bfs(graph, q, fq))
```
