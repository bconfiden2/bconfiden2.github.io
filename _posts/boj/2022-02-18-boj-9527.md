---
layout: post
title:  "[백준] 9527 : 1의 개수 세기"
subtitle:  ""
categories: ps
tags: boj
---

[문제 바로가기](https://www.acmicpc.net/problem/9527) --- **Gold 2** --- *# Mathematics # Prefix Sum # Bitmask*

---

자연수 A 와 B 사이에 있는 수들을 전부 이진수로 바꾼 뒤 1의 개수를 세기에는 값들의 범위가 너무 크기에 불가능하다.

이 때, 자연수 A의 이진수의 길이보다 큰 길이의 이진수들과, 자연수 B의 이진수 길이보다 작은 길이의 이진수들은 반드시 A와 B 범위 사이에 존재하기 때문에, 이진수의 길이 별로 1의 개수들을 구할 경우 그냥 더해주면 된다.

이진수 길이 별로 1의 개수들은, 몇번만 해보면 패턴 파악이 그닥 어렵지 않으므로 패쓰.

구해서 확인해보면, 예를 들어 이진수 길이가 2인 자연수들(2,3)의 전체 1의 개수는 3개이고, 길이가 3인 자연수들(4,5,6,7)은 8개, 길이가 4는 20개가 된다.

그러나 자연수 A의 이진수의 길이와 같은 길이를 갖는 자연수들의 경우에는, 해당 길이의 전체 개수를 그대로 더해줄 수 없고, B도 마찬가지이다.

따라서 이진수의 길이가 d 인 자연수들 중, val 값 이하인 자연수들의 1의 개수들을 구하는 함수 ```fd(d, val, pf)```를 사용하여 그에 대한 처리를 해줬다.

함수 fd는 길이가 d 인 자연수들에 해당하는 구간을 확인하며, 절반씩 나눠가며 재귀적으로 구한다.

사실 굉장히 가독성도 떨어지고 비효율적으로 푼 방식이기 때문에 자세한 내용은 설명 안하는게 낫다고 생각하며, 비트마스킹을 이용하면 훨씬 쉽게 풀 수 있는 문제이므로 다른 사람들 풀이가 100배 낫다. 반성하는 부분...

---

```python
# 이진탐색으로 절반씩 나눠가면서 목표값 이하 숫자의 1의 개수를 반환
def fd(d, val, pf):
    if d==2:
        return pf+1 if val==0 else 2*pf+3
    if val < 2**(d-2):
        return fd(d-1, val, pf)
    else:
        return pf*(2**(d-2)) + num[d-1] + fd(d-1, val-2**(d-2), pf+1)

A, B = map(int, input().split())
a, b = len(bin(A))-2, len(bin(B))-2
ans, num = (1 if a==1 else 0), [0, 1]
# 이진수 자릿수가 a+1 ~ b-1 인 수들은 모두 그대로 사용 가능
for i in range(2, b):
    num.append(2*num[i-1]+2**(i-2))
    if i >= a:
        ans += num[i]
# 자릿수가 b인 수들 중 B 이하인 수들의 1의 개수를 더해주고, 자릿수가 a인 수들 중 A 미만인 수들의 1의 개수는 빼줌
ans += (fd(b, B-2**(b-1), 0) if B!= 1 else 0) - (fd(a, A-2**(a-1)-1, 0) if A!=2**(a-1) else 0)
print(ans)
```
