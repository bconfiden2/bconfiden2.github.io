---
layout: post
title:  "[백준] 11049 : 행렬 곱셈 순서"
subtitle:  ""
categories: ps
tags: boj
---

[문제 바로가기](https://www.acmicpc.net/problem/11049) --- **Gold 3** --- *# Dynamic Programming*

---

단순하게 풀 경우에는 N개의 최소값을 위해 N-1개, N-2개, ... 2개의 최소값을 재귀적으로 구해야 돼서 연산량이 많아진다.

N-1개를 호출할때도 재귀적으로 N-2, N-3, ...2개의 값들을 구하고, N-2개도 마찬가지라 계산이 중복되는 것이다.

이런 중복 호출되는 값들에 대해서 메모이제이션을 통해 연산량을 줄일 수 있는데, 특정 위치에 특정 크기의 행렬에 대한 최소값을 저장해놓는다.

dp배열을 2차원으로 설정한 뒤, dp[r][c] 는 인덱스 r에서 시작하는 c개 만큼의 행렬에 대한 최소값으로 생각하면 된다.

예를 들어 r=3, c=3 일 경우 3번, 4번, 5번 행렬을 곱하는데 필요한 곱셈 연산의 최솟값이다.

각 위치에서의 최소값은 몇개 행렬을 곱하는지에 의해 결정되는데, 맨 마지막 행렬곱을 기준으로 나눈다.

즉 N개 행렬에 대해서는 아래와 같은 경우들 중 최솟값이 된다.
- 위의 N-1개를 곱한 뒤, 나머지 1개를 곱할 것인지
- 위에서 N-2개를 곱하고 아래 2개를 곱한 뒤, 그 둘을 곱할 것인지
- 위에서 N-3개를 곱하고 아래 3개를 곱한 뒤, 그 둘을 곱할 것인지
- ...
- 위의 2개를 곱하고, 아래 N-2개를 곱한 뒤, 그 둘을 곱할 것인지
- 아래 N-1개를 곱한 뒤, 맨 위의 행렬과 곱할 것인지

각 위치 r에 대해서 c개 행렬들에 대한 2차원 dp 값들을 쭉 갱신해나가면 최종적으로 N개 행렬에 대한 값을 구할 수 있다.

행렬의 개수가 최대 500개이기 때문에 O(n^3)으로 1초 안에 통과가 가능할 것으로 생각했지만, 파이썬이 아닌 PyPy로 제출해야 했다...(맞은 사람 목록은 pypy로만 도배)

---

```python
import sys
N = int(input())
mat = [tuple(map(int, L.split())) for L in sys.stdin]
dp = [[0 for c in range(N+1)] for r in range(N)]

# dp[r][c] = r위치에서 c개만큼의 최소연산횟수
for c in range(2, N+1):
    for r in range(N):
        if r > N-c: continue
        mini = 2**31-1
        # c개의 최소값은, ((c-1,1) (c-2,2) ... (1,c-1)) 들 중 최소값
        for p in range(c-1, 0, -1):
            q = c - p
            v = dp[r][p] + dp[r+c-q][q] + mat[r][0]*mat[r+p][0]*mat[r+c-1][1]
            if v < mini:
                mini = v
        dp[r][c] = mini

print(dp[0][N])
```
