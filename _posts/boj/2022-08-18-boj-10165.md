---
layout: post
title:  "[백준] 10165 : 버스 노선 : Platinum 5"
tags: boj
---

[문제 바로가기](https://www.acmicpc.net/problem/10165) --- *# Greedy # Sorting # Sweeping*

---

일직선 상에서 포함되는 선분을 찾는 것과 비슷한데, 원형으로 시작과 끝이 연결되어있다는 점에서 귀찮아지는 문제이다.

이를 해결하기 위해 원형으로 넘어오는 부분을 N(=10)을 초과한 값으로 변환해준다(예를 들어 `9-2`를 `9-12`, `8-3`을 `8-13`).

모든 노선들을 시작지점 기준으로 오름차순 정렬하고, 같은 시작지점 내에서는 도착지점 기준 내림차순 정렬한다.

정렬된 노선들을 앞에서부터 확인해나가면, 시작지점이 같은 노선들 중에서는 도착지점이 가장 먼 노선만 남기고는 전부 제외시킬 수 있다.

해당 노선만 남겨놓은 뒤, 다음 시작지점들에 해당하는 노선의 경우 역시 마찬가지로 가장 도착지점이 먼 노선만 남기고 전부 제외시키는데, 이 때 도착지점이 이전에 남은 노선의 도착지점보다 가까울 경우 역시 제외시킨다.

이렇게 모든 노선을 탐색하면 결국 0부터 N-1까지의 시작지점들 중 서로 겹치지 않는 노선들만 남게 되는데, 이 경우 `9-2`와 같이 N을 넘는 노선이 `0-1`의 노선을 덮는다는 사실을 알지 못한다.

따라서 남아있는 노선들을, 마지막 노선 기준으로 한번 더 필터링해주면 최종적으로 순환 도로 상에서 완전히 겹치는 노선들을 제거할 수 있다.

---

```python
import sys

N = int(input())
M = int(input())
arr = []
num = 1
for line in sys.stdin:
    a, b = map(int, line.strip().split())
    # 모든 노선을 한쪽 방향으로 통일
    if a > b:
        b += N
    # 도착지점을 먼 순서로 정렬하기 위해 음수로 삽입
    arr.append((a, -b, num))
    num += 1


tmp = []
bea = beb = -1
for a, b, n in sorted(arr):
    b = -b
    # 시작지점이 동일한 경우는 도착지점이 가장 먼 노드만 남겨놓음
    # 이전 노선에서의 가장 먼 도착지점보다 현재 노선의 가장 먼 도착지점이 가까울 경우 해당 노선 모두 제외
    if a == bea or b <= beb:
        continue
    bea, beb = a, b
    tmp.append((a, b, n))

# 마지막 노선이 덮을 수 있는 노선들을 확인
answer = []
for a, b, n in tmp:
    if b + N > beb:
        answer.append(n)
print(' '.join(map(str, sorted(answer))))
```
