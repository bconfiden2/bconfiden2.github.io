---
layout: post
title:  "[백준] 1562 : 계단 수 : Gold 1"
tags: boj
---

[문제 바로가기](https://www.acmicpc.net/problem/1562) --- *# Dynamic Programming # Bitmask*

---

3차원 dp[i][j][k]는, 길이가 i 이고 마지막이 j 로 끝난 계단수들 중 지금까지 0~9까지의 숫자들의 등장여부를 비트마스크로 표현했을 때 k인 
계단수의 개수를 담는다.

계단 수의 특성상 인접한 모든 자리수끼리 차이가 1이어야 하기 때문에, j가 이 정보를 반영하기 위한 배열이다.

또한 현재 계단수에서 0부터 9까지의 숫자들 중 어떠어떠한 숫자가 등장했는지 여부를 각각 비트로 활용하여 10비트짜리 숫자 하나로 표현하는 것이 k가 된다.

그렇기 때문에 삼중 반복문을 전부 돌면서 이전 계단수에서 새롭게 만들어지는 계단수들 중, 이번에 등장한 자리수가 k 에 반영되었을 때 가능한 계단수들을 구해나간다.

새롭게 만들어지는 계단수는, 이전에 끝난 수 j에서 연결되어야 하기 때문에 이번에는 j+1 혹은 j-1 에서만 가능하며, 이번에 j 를 방문하기 때문에 k 와 ```1<<j``` 를 비트연산한 결과로 dp배열을 갱신할 수 있다.

어차피 길이 i 에 대해서는, 이전 i-1 값만 참조하기 때문에 굳이 모든 i 값들을 담고 있을 필요는 없다.

슬라이딩해나가면서 메모리를 아낄 수도 있겠다.

---

```python
N = int(input())
# dp[i][j][k] = 길이가 i 이며, 마지막이 j 로 끝났으며, 지금까지 등장한 숫자들을 비트로 표현했을 때의 계단수의 개수
dp = [[[0 for _ in range(1024)] for _ in range(10)] for _ in range(N+1)]
# 길이가 1인 경우 0 시작 제외
for i in range(1, 10):
    dp[1][i][2**i] = 1
for i in range(2, N+1):
    for j in range(10):
        for k in range(1024):
            # 이번에 j 가 등장한다면, 이전에 j-1 혹은 j+1 로 끝난 모든 수들을
            # j 를 방문했을때 변화되는 k 의 비트에다가 더해줌
            x = k | (1 << j)
            # 마지막이 0으로 끝난 경우
            if j > 0: dp[i][j][x] += dp[i-1][j-1][k]
            # 마지막이 9로 끝난 경우
            if j < 9: dp[i][j][x] += dp[i-1][j+1][k]
            dp[i][j][x] %= 1000000000
# 길이가 N일때 0부터 9까지 모든 숫자가 등장한(k=1023) 계단수의 개수
print(sum(dp[N][i][1023] for i in range(10)) % 1000000000)
```
