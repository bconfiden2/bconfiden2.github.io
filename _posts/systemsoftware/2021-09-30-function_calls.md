
RTN 레지스터

### Jcall / Jret
함수호출하면 subroutine의 해당 위치로 점프했다가, 함수가 끝나면 호출 다음 위치로 다시 돌아가기
PC가 45를 가리키고있을때 50으로 점프한거니까 돌아갈 위치 JRET 46이라는건 알고있으니까 이걸 가져다가 점프한뒤 다시 실행 쭉
fetch decoding 은 PC 에서 읽어와서 IR 이 디코딩하는것까지. 이건 기본이라고 가정하고 나머지에 대해서만 보자.
IR에서 OPcode가 Jcall 임을 확인했음, 그럼 Jcall 은 점프를 하는 친구인데, 어디로 점프할것인가 -> 피연산자 ADDR
근데 이 전에 돌아올 주소를 RTN 레지스터에 저장해놓기! (현재 PC + 1) 값
점프한 뒤 서브루틴 실행하고 다 끝나면 RTN 값을 PC 에 옮겨써놓으면 되는것
레지스터간에는 서로 하드웨어적으로 연결돼있기 때문에, 어떠 ㄴ신호가 발생하면 전기가 흘러서 따닥 옮겨짐!

### V05 이상에서는?
근데 우리는 이걸 명령어로 만들지는 않음. 대신 있는 명령어를 조합해서 Jcall Jret 에 해당하는 일을 할 것.
SETRTN 이라는 명령
# 이부분 다시듣기!!!!


### 문제점
서브루틴 안에서 또다시 서브루틴 Jcall 을 때리면 RTN 값이 또다시 바뀌기 때문에 앞선 JRET 이 날라감

반환받을 주소가 더 필요해지는것. 

### Jsub / Rsub
반환할 주소를 RTN 레지스터가 아닌 메모리에 저장. 서브루틴 코드 시작부분 바로 윗부분. 어셈블러가 알아서 해당 위치를 비워놓음(50번지에서 시작한다면 49번지를 비워놓기).
그럼 Jsub 는 어떻게 구현되나 - 메모리 write
MAR = IR[ADDR] - 1 (바로 윗부분)
MDR = PC + 1 (Jret)
memoryWrite()

Rsub
